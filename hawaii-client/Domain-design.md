

# Domain Design (v0.1)

**Audience:** F#-fluent contributors new to this repo.

**Goal:** Explain the high‑level domain model we’re adopting for Businesses and Accounts so that streaming, laziness, and backend‑agnosticism are preserved. This document is intentionally light on implementation details; code snippets are illustrative only and **not authoritative**.

---

## Guiding principles

1. **Business scope is first‑class.** You must opt into a *business context* before you can enumerate or compute on its data.
2. **Streams everywhere.** We expose paginated resources as `AsyncSeq<'a>` (or equivalent) and only materialize when the caller chooses.
3. **Lazy hydration.** Entities flow through the system as `Partial` until/if callers request details (`hydrate`), which is idempotent.
4. **Pure folds over streams.** Balance sheets, hierarchies, etc. are *functions of streams*, not mutable fields on entities.
5. **Backend‑agnostic.** The public surface hides transport types (Hawaii/OpenAPI). We can swap or add backends later without rewriting domain folds.

---

## Core identities & entities

### Business identity

As of now, we have `BusinessIdentifier` in `Types.fs` (generated by Hawaii). We will treat **identity** as a *value object* that’s printable, comparable, and contains no effects.

- **Recommendation:** Keep identity minimal and pure.
  - `BusinessKey = { id : BusinessIdentifier; slug : string option }`
  - The **slug** *may* be unknown initially (hence `option`) and discovered on hydration.

> Why *not* put a `fetch` function inside the key? Because keys should be pure and serializable; we keep effects in the `Business` entity or in `BusinessContext`.

### Business entity (lazy)

We mirror the account pattern: a discriminated union with a closure that can produce a *full* structure on demand.

```fsharp
// Illustrative only
type BusinessFull = {
  key        : BusinessKey
  name       : string
  slug       : string
  currency   : string              // accounting currency for this business
  country    : string option       // e.g., "FI"
  fiscalYear : { startsOn: System.DateTime option }
  features   : Set<BusinessFeature> // capability flags discovered via API
  // no collections here; see BusinessContext for streaming access
}

// Partial carries just enough to hydrate when needed
// hydrate returns the full shape; it is idempotent
// (We keep effects *here* or in context, not in the key.)
type Business =
  | Partial of key: BusinessKey * hydrate: (unit -> Async<Business>)
  | Full    of BusinessFull
```

**Hydration semantics:**
- Hydrating a **Business** loads only *business meta* (name, slug if missing, currency, fiscal year, features). It **does not** fetch accounts, documents, or entries.
- Collections are accessed via `BusinessContext` as streams.

### Account entity (already exists)

We keep your current `Account` partial/full pattern. Accounts may be streamed and hydrated lazily. The *classification* layer (see below) is a domain wrapper over API enums.

---

## BusinessContext (scope + operations)

**Concept:** A small record that binds the environment (HTTP, base URL, auth) with a `BusinessKey` and exposes *scoped* operations. Think of it as a light DDD repository bound to a single aggregate root (Business).

```fsharp
// Illustrative only
/// Created from env + BusinessKey (or Business)
type BusinessContext = {
  key   : BusinessKey
  env   : BackendEnv          // http client, baseUrl, auth, etc.
  opts  : ContextOptions      // page sizes, retry policy, etc.
}

module BusinessContext =
  val hydrate   : BusinessContext -> Async<Business>  // meta only
  val streamAccounts : BusinessContext -> AsyncSeq<Account>
  val tryGetAccount  : BusinessContext -> AccountId -> Async<Account option>
  // future:
  val streamDocuments : BusinessContext -> AsyncSeq<Document>
  val streamEntries   : BusinessContext -> AsyncSeq<Entry>
```

**Invariants:**
- Every value produced by a `BusinessContext` belongs to *that* business (enforced by construction and tests).
- No hidden global state; caches (if any) live behind the context and are optional.

**Why this shape?**
- Callers first *enter* a business: `let ctx = BusinessContext.ofKey env key`.
- From there, all I/O is naturally scoped, and *folds* can be kept pure and re‑usable.

---

## What does “hydrate a business” fetch?

**Yes:** business metadata that is stable-ish and frequently needed for interpretation:
- Display name
- Slug (if not already known)
- Accounting currency (base currency used for reporting)
- Country / VAT regime hints (if exposed)
- Fiscal year anchor (start date / policy) if exposed
- Feature flags / capabilities (e.g., which endpoints exist, page size limits)

**No (on hydrate):** potentially large collections like accounts, documents, entries, balances. Access those via streaming functions on the context.

This separation keeps hydration cheap and preserves laziness.

---

## Classification as a domain ADT

We’ll wrap API enums in a small **domain DU** so we can normalize across API versions and support future features (like contra accounts) without upheaval.

```fsharp
// Illustrative only
/// High-level class used by balance sheet / P&L folds
[<RequireQualifiedAccess>]
type AccountClass =
  | Asset
  | Liability
  | Equity
  | Income
  | Expense
  | Contra of AccountClass          // optional, for contra-accounts
  | Other of string                 // forward-compatible, opaque tag

/// Debit/Credit nature can be useful in folds & validations
[<RequireQualifiedAccess>]
type AccountNature = Debit | Credit

/// Header path from API becomes a non-empty path in the domain
/// (safer for tree construction)
type HeaderPath = NonEmptyList<string>
```

Then provide a single mapping function at the edge:

```fsharp
module Classification =
  val ofApi : Types.Type92dEnum -> Result<AccountClass, string>
```

You can keep the API enum at the edges, immediately convert to `AccountClass`, and have *all* downstream logic depend on the domain ADT. If the API changes, you update `Classification.ofApi` (and maybe add an `Other` case), *not* every fold.

---

## Views & folds (pure)

**Account tree**
- Input: `AsyncSeq<Account>` (from `BusinessContext.streamAccounts`).
- Process: map each account to `(HeaderPath, AccountId, name, class)` and fold into a tree. You’ll likely materialize this at the end because a tree is inherently a whole-collection view.
- Output: an immutable `AccountTree` structure ready for UI/printing.

**Balance sheet (as‑of)**
- Input: `AsyncSeq<Account>` + (optionally) balances as of date/period if the API exposes them; otherwise derive from entries.
- Process: fold by `AccountClass` and `HeaderPath` into totals. Ensure uniqueness by `AccountId` if you traverse multiple pages.
- Output: a `BalanceSheetSnapshot` record (pure data) and a list of warnings for incomplete data.

Keep both as standalone modules that operate on streams and return pure data; no I/O inside folds.

---

## Cross‑business comparison (future seam)

We’ll need an **alignment** layer rather than comparing raw accounts:

- Define a `CommonAccountCode` taxonomy (stable codes under our control).
- Maintain per‑business mapping tables: `BusinessKey -> Map<AccountId, CommonAccountCode>` (backed by config, DB, or the API if supported).
- Provide a transform: `AsyncSeq<Account> -> AsyncSeq<AlignedAccount>` that tags or projects accounts into the common space.
- Only after alignment do we aggregate across businesses.

If/when we adopt tagging (Option #2), we can carry `business : BusinessKey` inside `Account` to make illegal cross‑mixing obvious in tests.

---

## Testing & invariants

- **Scope invariant:** Any `Account` produced by `BusinessContext(key).streamAccounts` belongs to `key`.
- **Hydration idempotency:** Hydrating the same `Business` twice yields the same `Full` (modulo time‑varying fields), and never mixes data between businesses.
- **Classification totality:** `Classification.ofApi` should be total for known API values and return `Error`/`Other` for unknown ones—never throw.
- **Fold robustness:** Folds tolerate missing optional fields and surface warnings instead of failing hard.

Property tests are a good fit for these.

---

## Open questions for this repo

1. **Slug availability:** Does the API expose a stable `slug` for businesses? If not, shall we derive one from `name` (and treat it as unstable until confirmed)?
2. **Business metadata surface:** Which of these are available now via Hawaii types? `currency`, `country/VAT`, `fiscalYear`? Please list exact field names once confirmed.
3. **Single vs multi‑currency:** Do balances/entries ever mix currencies per business? (Assumption for now: a single accounting currency per business.)
4. **Header path guarantees:** Is `header_path` guaranteed non‑empty and stable? If not, we should define our own `HeaderPath` normalization.
5. **Capabilities probing:** Do we have an endpoint to discover supported features (e.g., balances, documents)? If not, we may infer via 404/501 and cache.

---

## Next steps (non‑binding)

1. Confirm the **Business metadata** fields from generated Hawaii types and list them here.
2. Add thin **signature stubs** (no logic) for `BusinessContext` and classification mapping.
3. Implement the first **pure fold**: building the account tree from an `AsyncSeq<Account>`.
4. Only then wire the actual streaming calls inside `BusinessContext`.

---

*This document will evolve; prefer updating it before touching multiple call sites. Keep domain types small, streams lazy, folds pure.*
